## Problem 20: Multiplication Table (Very Hard)

### Solution
```python
size = 5

for i in range(1, size + 1):
    for j in range(1, size + 1):
        product = i * j
        print(f"{product:4}", end="")
    print()  # Newline after each row
```

**Output:**
```
   1   2   3   4   5
   2   4   6   8  10
   3   6   9  12  15
   4   8  12  16  20
   5  10  15  20  25
```

### Explanation
- Nested loops for rows and columns
- Outer loop: i from 1 to 5
- Inner loop: j from 1 to 5
- Calculate and print product
- `:4` formats with 4-character width
- Creates aligned multiplication table

---

## Key Concepts Demonstrated

1. **Direct Iteration**: `for item in sequence` - no indexing needed
2. **Enumerate**: Get index and value together
3. **Zip**: Iterate multiple sequences in parallel
4. **Dictionary Methods**: `.items()`, `.keys()`, `.values()`
5. **Nested Loops**: Iterate 2D structures
6. **Accumulator Pattern**: Build sum, max, new lists
7. **Tuple Unpacking**: Extract multiple values per iteration
8. **Reversed**: Iterate backwards
9. **List Comprehension**: Concise alternative to for loops
10. **Filter Pattern**: Collect items matching condition

## For Loop vs While Loop

| Feature | For Loop | While Loop |
|---------|----------|------------|
| **Use case** | Known sequence | Unknown iterations |
| **Syntax** | `for item in seq:` | `while condition:` |
| **Iteration** | Automatic | Manual |
| **Indexing** | Optional (enumerate) | Manual counter |
| **Best for** | Lists, strings, ranges | Conditions, user input |

## Common Patterns

```python
# Pattern 1: Iterate sequence
for item in sequence:
    process(item)

# Pattern 2: Accumulate
total = 0
for num in numbers:
    total += num

# Pattern 3: Build new list
result = []
for item in sequence:
    result.append(transform(item))

# Pattern 4: Enumerate
for index, item in enumerate(sequence):
    print(f"{index}: {item}")

# Pattern 5: Zip multiple
for a, b in zip(list1, list2):
    combine(a, b)

# Pattern 6: Dictionary iteration
for key, value in dictionary.items():
    process(key, value)

# Pattern 7: Nested
for row in matrix:
    for item in row:
        process(item)

# Pattern 8: Filter
result = []
for item in sequence:
    if condition(item):
        result.append(item)
```

## Best Practices

1. **Use for over while**: When iterating sequences
2. **Meaningful names**: `for student in students` not `for s in s`
3. **Enumerate when needed**: Don't manually track index
4. **Zip for parallel**: Better than indexing multiple lists
5. **Dictionary methods**: Use `.items()` for key-value pairs
6. **List comprehension**: For simple transformations
7. **Break and continue**: Work same as in while loops
8. **Keep simple**: Avoid deeply nested loops when possible

## Python-Specific Features

- **No semicolons**: Clean syntax
- **Indentation matters**: Defines loop body
- **Works on any iterable**: Lists, tuples, strings, ranges, files
- **Unpacking**: Extract multiple values per iteration
- **Built-in functions**: `enumerate()`, `zip()`, `reversed()`
- **Comprehensions**: List, dict, set comprehensions
- **Else clause**: Runs if loop completes without break

## Common Mistakes

1. **Modifying list during iteration**: Creates issues
2. **Not understanding enumerate**: Manually tracking index
3. **Forgetting colon**: Syntax error
4. **Wrong indentation**: Not part of loop
5. **Using index when not needed**: Less Pythonic
6. **Not using zip**: Parallel iteration with indexing
7. **Deep nesting**: Hard to read and maintain
