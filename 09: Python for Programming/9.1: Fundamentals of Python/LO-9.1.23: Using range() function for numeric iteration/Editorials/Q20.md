## Problem 20: Grid Coordinates (Very Hard)

### Solution
```python
for row in range(3):
    for col in range(4):
        print(f"({row},{col})", end=" ")
    print()
```

**Output:**
```
(0,0) (0,1) (0,2) (0,3)
(1,0) (1,1) (1,2) (1,3)
(2,0) (2,1) (2,2) (2,3)
```

### Explanation
- 3 rows (0, 1, 2)
- 4 columns per row (0, 1, 2, 3)
- Nested ranges for 2D grid
- Total 12 coordinates
- Common pattern for matrices

---

## Key Concepts Demonstrated

1. **Single argument**: `range(n)` → 0 to n-1
2. **Two arguments**: `range(start, stop)` → start to stop-1
3. **Three arguments**: `range(start, stop, step)` → custom increment
4. **Negative step**: Count backwards
5. **Exclusive stop**: Stop value not included
6. **Zero-based**: Default start is 0
7. **Iteration control**: Precise number of loops
8. **Index generation**: Create indices for lists
9. **Nested ranges**: Multi-dimensional iteration
10. **Pattern generation**: Steps create sequences

## Range Syntax Summary

```python
# Basic forms
range(5)           # 0, 1, 2, 3, 4
range(1, 6)        # 1, 2, 3, 4, 5
range(0, 10, 2)    # 0, 2, 4, 6, 8

# Backward counting
range(10, 0, -1)   # 10, 9, 8, ..., 1
range(5, -1, -1)   # 5, 4, 3, 2, 1, 0

# Empty ranges
range(0)           # Empty
range(5, 5)        # Empty
range(10, 1)       # Empty (need negative step)

# Common patterns
range(len(list))   # Indices of list
range(1, n+1)      # 1 to n inclusive
range(0, n, 2)     # Even numbers
range(1, n, 2)     # Odd numbers
```

## Best Practices

1. **Use range for counting**: Better than while with counter
2. **Remember exclusive stop**: `range(1, 11)` for 1-10
3. **Prefer enumerate**: Instead of `range(len(list))`
4. **Use step wisely**: For patterns like evens/odds
5. **Negative step for reverse**: Must have start > stop
6. **Single arg for iterations**: `range(n)` when just counting
7. **List when needed**: `list(range(5))` → [0, 1, 2, 3, 4]

## Common Mistakes

1. **Forgetting exclusive stop**: `range(10)` goes 0-9, not 0-10
2. **Wrong direction**: `range(10, 1)` is empty, need `range(10, 1, -1)`
3. **Float arguments**: range only accepts integers
4. **Modifying in loop**: Don't change range variable value
5. **Over-using with lists**: Use `for item in list` instead of indices
6. **Forgetting +1**: `range(n)` for n iterations, `range(1, n+1)` for 1 to n

## Range vs List

```python
# Range is memory efficient
r = range(1000000)      # Instant, little memory
l = list(range(1000000)) # Slow, lots of memory

# Range is lazy (generates on demand)
for i in range(1000000):
    if i == 10:
        break  # Only generated 0-10, not all million

# Convert to list when needed
numbers = list(range(1, 6))  # [1, 2, 3, 4, 5]
```

## Advanced Patterns

```python
# Reverse with negative step
for i in range(10, 0, -1):  # 10 down to 1

# Every nth element
for i in range(0, len(list), n):
    process(list[i])

# Pairs of indices
for i in range(0, len(list)-1):
    compare(list[i], list[i+1])

# Chunks
for i in range(0, len(list), chunk_size):
    chunk = list[i:i+chunk_size]

# Skip first/last
for i in range(1, len(list)-1):
    process(list[i])
```
