### **30. Create Report Header with Defaults**

Define a function `create_header` that takes title, an optional width with default 50, and an optional border_char with default "=". Return a formatted header.

**Expected Output:**
```python
print(create_header("Report"))
# ==================================================
#                      Report
# ==================================================

print(create_header("Summary", 30, "-"))
# ------------------------------
#           Summary
# ------------------------------
```

**Hint:** Center the title and create borders with `border_char * width`

---

## Key Concepts

### What Are Default Parameters?

Default parameters allow you to specify default values for function parameters. If the caller doesn't provide a value, the default is used.

```python
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

# Use default
print(greet("Alice"))  # Hello, Alice!

# Override default
print(greet("Bob", "Hi"))  # Hi, Bob!
```

### Syntax

```python
def function_name(required_param, optional_param=default_value):
    # Function body
    pass
```

**Rules:**
1. Parameters with defaults must come AFTER parameters without defaults
2. Default value is evaluated once when function is defined
3. Can have multiple default parameters
4. Can override defaults by position or by name

### Why Use Default Parameters?

**Benefits:**
1. **Flexibility**: Function works with or without optional arguments
2. **Backward compatibility**: Add new parameters without breaking existing calls
3. **Cleaner code**: Avoid multiple function versions
4. **Common defaults**: Set sensible defaults for typical use cases
5. **Optional features**: Make advanced features optional

### Parameter Order Rules

```python
# WRONG - Default before required
def wrong(name="Guest", age):  # SyntaxError!
    pass

# RIGHT - Required before defaults
def correct(age, name="Guest"):
    pass
```

**Required parameters must come BEFORE default parameters!**

### Overriding Defaults

```python
def calculate(x, y=2, z=3):
    return x + y + z

# Use all defaults
print(calculate(1))  # 1 + 2 + 3 = 6

# Override one default
print(calculate(1, 5))  # 1 + 5 + 3 = 9

# Override both defaults
print(calculate(1, 5, 10))  # 1 + 5 + 10 = 16

# Use keyword arguments
print(calculate(1, z=10))  # 1 + 2 + 10 = 13
```

### Common Patterns

**Pattern 1: Optional Configuration**
```python
def connect_database(host, port=5432, timeout=30):
    # Use default port and timeout if not specified
    pass
```

**Pattern 2: Optional Formatting**
```python
def format_number(num, decimals=2, currency="$"):
    return f"{currency}{num:.{decimals}f}"
```

**Pattern 3: Optional Behavior**
```python
def save_file(data, backup=True):
    # Save file
    if backup:
        # Create backup
        pass
```

**Pattern 4: Multiple Defaults**
```python
def draw_rectangle(width=10, height=5, char="*"):
    for i in range(height):
        print(char * width)
```

### Mutable Default Arguments Warning

**DANGER: Don't use mutable objects as defaults!**

```python
# WRONG - Mutable default
def add_item(item, items=[]):  # BAD!
    items.append(item)
    return items

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] - Unexpected!

# RIGHT - Use None and create new list
def add_item(item, items=None):  # GOOD!
    if items is None:
        items = []
    items.append(item)
    return items

print(add_item(1))  # [1]
print(add_item(2))  # [2] - Correct!
```

**Why?** Default values are evaluated once when the function is defined, not each time it's called. Mutable objects (lists, dicts) will be shared across calls!

### Best Practices

1. **Use immutable defaults**: Strings, numbers, tuples, None
2. **Descriptive names**: Make default values obvious
3. **Sensible defaults**: Choose common, safe default values
4. **Document defaults**: Comment what the default means
5. **Don't overuse**: Too many defaults can confuse users
6. **Test both cases**: Test with and without defaults

### When to Use Default Parameters

**Use defaults when:**
- Parameter has a typical/common value
- Making parameters optional improves usability
- Adding backward-compatible features
- Configuration options with standard settings
- Optional formatting/display preferences

**Don't use defaults when:**
- Every call needs a different value
- No sensible default exists
- Value depends on other parameters
- Security-sensitive parameters (require explicit values)

### Default Values Can Be Expressions

```python
def log_message(message, timestamp=None):
    if timestamp is None:
        timestamp = datetime.now()  # Evaluated at call time
    print(f"[{timestamp}] {message}")
```

### Real-World Applications

1. **API Functions**: Default timeout, retry attempts
2. **File Operations**: Default encoding, mode
3. **Web Requests**: Default headers, timeout
4. **Database Queries**: Default limit, offset
5. **UI Functions**: Default colors, sizes, positions
6. **Math Functions**: Default precision, rounding mode
