## Problem 15: All Combinations

**Problem:** Print all 3-digit combinations from digits 0-2.

**Solution:**
```python
for hundreds in range(3):
    for tens in range(3):
        for ones in range(3):
            print(f"{hundreds}{tens}{ones}", end=' ')
        print()  # New line after each row of tens
```

**Output:**
```
000 001 002
010 011 012
020 021 022
100 101 102
110 111 112
120 121 122
200 201 202
210 211 212
220 221 222
```

**Explanation:**
- Triple nested loop for 3 positions
- Outer: hundreds place (0, 1, 2)
- Middle: tens place (0, 1, 2)
- Inner: ones place (0, 1, 2)
- Total combinations: 3 × 3 × 3 = 27

**Key Concept:** Triple nesting for three-level combinations.

---

## Problems 16-30: Summary Solutions

Due to space, here are concise solutions for remaining problems:

**Problem 16: Prime Number Grid** - Nested loops with is_prime helper function checking each element.

**Problem 17: Row and Column Sums** - First nested loop sums rows, second nested loop sums columns.

**Problem 18: Pascal's Triangle** - Build each row from previous row using nested loops.

**Problem 19: Spiral Matrix** - Track direction and boundaries while filling matrix spirally.

**Problem 20: Diamond Pattern** - Combine increasing triangle (spaces decrease, stars increase) with decreasing triangle.

**Problem 21: Flatten 2D List** - Nested loops append each element to new 1D list.

**Problem 22: Common Elements** - Nested loops check if element exists in all lists.

**Problem 23: Nested Counters** - Count total iterations: outer × middle × inner.

**Problem 24: Matrix Multiplication** - Triple nested: i for rows, j for cols, k for dot product.

**Problem 25: Border Pattern** - Print '*' when row or col is 0 or max, else space.

**Problem 26: Times Table** - Outer loop for number, inner for multipliers 1-5.

**Problem 27: Sum Diagonal** - Sum elements where `matrix[i][i]`.

**Problem 28: Identity Matrix** - Set to 1 when i==j, else 0.

**Problem 29: All Substrings** - Outer for start, inner for end, slice `s[start:end]`.

**Problem 30: Sequential Matrix** - Track counter, increment for each position.

---

## Key Patterns Summary

### 1. Rectangle (m × n)
```python
for i in range(m):
    for j in range(n):
        print('*', end=' ')
    print()
```

### 2. Right Triangle
```python
for i in range(n):
    for j in range(i + 1):
        print('*', end=' ')
    print()
```

### 3. Inverted Triangle
```python
for i in range(n, 0, -1):
    for j in range(i):
        print('*', end=' ')
    print()
```

### 4. Pyramid (with spaces)
```python
for i in range(1, n+1):
    print(' ' * (n-i), end='')
    print('* ' * i)
```

### 5. 2D List Processing
```python
for row in matrix:
    for element in row:
        process(element)
```

### 6. With Indices
```python
for i in range(len(matrix)):
    for j in range(len(matrix[i])):
        print(matrix[i][j])
```

### 7. Conditional Patterns
```python
for i in range(n):
    for j in range(n):
        if condition(i, j):
            print('X')
        else:
            print('O')
    print()
```

---

## Common Pitfalls

1. **Index Confusion:** Swapping i and j
2. **Missing Newline:** Forgetting `print()` after inner loop
3. **Range Errors:** Using wrong range for variable-sized patterns
4. **Break Issues:** Not propagating break to outer loop
5. **Performance:** Not considering O(n²) or O(n³) complexity

---

## Best Practices

1. **Descriptive Names:** Use `row, col` instead of `i, j`
2. **Comments:** Document what each level represents
3. **Test Small:** Start with 3×3 before scaling
4. **Visualize First:** Draw expected output
5. **Extract Logic:** Move complex operations to functions
