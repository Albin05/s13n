### **30. Return Filtered List**

Write a function `get_evens` that takes a list and returns a new list with only even numbers.

**Expected Output:**
```python
result = get_evens([1, 2, 3, 4, 5, 6])
print(result)  # [2, 4, 6]

result = get_evens([1, 3, 5])
print(result)  # []
```

**Hint:** Use list comprehension or loop to build new list with evens.

---

## Key Concepts

### What is Return?

```python
def function_name():
    # Do some work
    return value  # Send value back
```

The `return` statement:
- Sends a value back to the caller
- Exits the function immediately
- Can return any data type
- Returns `None` if no value specified

### Return vs Print

```python
# Print - displays but doesn't return value
def add_print(a, b):
    print(a + b)  # Shows on screen

result = add_print(5, 3)  # Displays: 8
print(result)  # None (function returned nothing)

# Return - sends value back
def add_return(a, b):
    return a + b  # Send back the sum

result = add_return(5, 3)  # result gets 8
print(result)  # 8
```

**Key Difference:**
- `print()` → For displaying output to users
- `return` → For sending data back to use in code

### Using Returned Values

```python
def square(n):
    return n * n

# Store in variable
x = square(5)  # x = 25

# Use in calculation
y = square(3) + square(4)  # y = 9 + 16 = 25

# Pass to another function
print(square(10))  # Prints 100

# Use in conditions
if square(2) == 4:
    print("Correct!")
```

### Multiple Return Statements

```python
def check_sign(num):
    if num > 0:
        return "Positive"
    elif num < 0:
        return "Negative"
    else:
        return "Zero"

# Only ONE return executes (first match)
print(check_sign(5))   # "Positive"
print(check_sign(-3))  # "Negative"
```

### Early Return Pattern

```python
def validate_input(value):
    # Check error cases first
    if value < 0:
        return "Error: Negative value"
    if value > 100:
        return "Error: Too large"

    # Main logic only runs if valid
    return "Valid"
```

**Benefits:**
- Clearer error handling
- Avoids deep nesting
- Exits early on errors

### Returning Multiple Values

```python
def calculate_stats(numbers):
    total = sum(numbers)
    average = total / len(numbers)
    return total, average  # Returns tuple

# Unpack returned values
sum_val, avg_val = calculate_stats([1, 2, 3, 4, 5])
print(f"Sum: {sum_val}, Average: {avg_val}")
```

### Return None

```python
# Explicit return None
def do_something():
    print("Working...")
    return None

# Implicit return None (no return statement)
def do_something_else():
    print("Working...")
    # Automatically returns None

x = do_something()  # x is None
y = do_something_else()  # y is None
```

### Common Patterns

**Pattern 1: Calculation and Return**
```python
def calculate_total(price, quantity):
    total = price * quantity
    return total
```

**Pattern 2: Validation and Return Boolean**
```python
def is_valid_email(email):
    if '@' not in email:
        return False
    if '.' not in email:
        return False
    return True
```

**Pattern 3: Find and Return**
```python
def find_item(items, target):
    for item in items:
        if item == target:
            return item
    return None  # Not found
```

**Pattern 4: Process and Return List**
```python
def double_all(numbers):
    result = []
    for num in numbers:
        result.append(num * 2)
    return result
```

### Best Practices

1. **Return Consistent Types**: Don't return string sometimes, number other times
2. **Document Return Values**: Comment what function returns
3. **Use Descriptive Names**: Function name should hint at return value
4. **Return Early for Errors**: Check errors first, return early
5. **Avoid Side Effects**: Function should return value, not modify globals

### Common Mistakes

1. **Forgetting to Return**
   ```python
   # WRONG
   def add(a, b):
       a + b  # Calculated but not returned!

   # RIGHT
   def add(a, b):
       return a + b
   ```

2. **Code After Return**
   ```python
   # WRONG - Second line never runs
   def get_value():
       return 10
       print("This never prints!")  # Unreachable

   # RIGHT
   def get_value():
       print("Calculating...")
       return 10
   ```

3. **Return in Wrong Scope**
   ```python
   # WRONG - Return inside loop exits function
   def sum_list(numbers):
       for num in numbers:
           return num  # Only returns first element!

   # RIGHT
   def sum_list(numbers):
       total = 0
       for num in numbers:
           total += num
       return total  # Returns after all processing
   ```

4. **Not Using Returned Value**
   ```python
   # Wasteful - result not used
   add(5, 3)  # Returns 8, but value is lost

   # Better - store and use
   result = add(5, 3)
   print(result)
   ```

### When to Use Return vs Print

**Use Return When:**
- You need the value for further calculations
- Result will be stored in a variable
- Function result will be passed to another function
- Building reusable, composable functions

**Use Print When:**
- Debugging
- Displaying information to user
- Logging progress
- Creating output for reports

**Often Use Both:**
```python
def calculate_and_display(a, b):
    result = a + b
    print(f"Calculating: {a} + {b} = {result}")  # Display
    return result  # Also return for use
```

### Real-World Applications

1. **Calculations**: Return computed values
2. **Validation**: Return True/False for checks
3. **Data Processing**: Return transformed data
4. **API Functions**: Return results from operations
5. **Helper Functions**: Return intermediate values
6. **Utilities**: Return formatted/processed data
