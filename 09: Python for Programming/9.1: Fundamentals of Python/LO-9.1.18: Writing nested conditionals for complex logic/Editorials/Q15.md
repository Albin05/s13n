## Problem 15: University Admission Decision (Very Hard)

### Solution
```python
gpa = 3.7
sat_score = 1350
extracurricular_count = 4
essay_score = 8  # out of 10
recommendation_quality = "excellent"

admission_points = 0

if gpa >= 3.5:
    if sat_score >= 1400:
        admission_points += 30
    elif sat_score >= 1200:
        admission_points += 20
    else:
        admission_points += 10
else:
    if sat_score >= 1450:
        admission_points += 15
    else:
        admission_points += 5

if extracurricular_count >= 5:
    if essay_score >= 8:
        admission_points += 20
    else:
        admission_points += 15
elif extracurricular_count >= 3:
    if essay_score >= 7:
        admission_points += 15
    else:
        admission_points += 10
else:
    admission_points += 5

if recommendation_quality == "excellent":
    admission_points += 15
elif recommendation_quality == "good":
    admission_points += 10
else:
    admission_points += 5

if admission_points >= 60:
    decision = "Accepted"
elif admission_points >= 45:
    decision = "Waitlisted"
else:
    decision = "Rejected"

print(f"Admission points: {admission_points}")
print(f"Decision: {decision}")
```

**Output:**
```
Admission points: 50
Admission decision: Waitlisted
```

### Explanation
- Point breakdown:
  - GPA 3.7 + SAT 1350 → 20 points
  - 4 activities + essay 8 → 15 points
  - Excellent recommendation → 15 points
  - Total: 50 points → Waitlisted
- Holistic admissions criteria:
  - Academic performance (GPA + SAT)
  - Extracurricular involvement
  - Essay quality
  - Recommendations
- Decision thresholds:
  - 60+ points → Accepted
  - 45-59 points → Waitlisted
  - Under 45 → Rejected
- Nested structure allows compensation (weak GPA can be offset by strong SAT)
- Models real university admissions process

---

## Key Concepts Demonstrated

1. **Validation First**: Check inputs before processing
2. **Hierarchical Logic**: Outer conditions control inner logic
3. **Clear Error Messages**: Specific feedback for each path
4. **Complex Decision Trees**: Multiple factors influence outcome
5. **Defense in Depth**: Layer security checks
6. **Readable Indentation**: Proper formatting shows structure
7. **Avoid Deep Nesting**: Refactor if more than 3-4 levels
8. **Calculate Once**: Store intermediate values
9. **Consistent Patterns**: Similar problems use similar structures
10. **Real-World Models**: Practice with authentic scenarios

## Best Practices

- Keep nesting to 3-4 levels maximum for readability
- Use meaningful variable names
- Add comments for complex conditions
- Consider using `and`/`or` to flatten simple nested conditions
- Test all possible paths through nested logic
- Provide specific feedback for each outcome
- Validate inputs before complex calculations
