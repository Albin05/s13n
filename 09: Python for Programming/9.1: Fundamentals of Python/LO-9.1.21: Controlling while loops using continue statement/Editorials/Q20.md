## Problem 20: Temperature Validator (Very Hard)

### Solution
```python
readings = [22.5, -999, 23.1, 150, 21.8, -999, 24.2, -10]
valid_temps = []

for temp in readings:
    # Skip sensor errors (-999)
    if temp == -999:
        print(f"Skipping error reading: {temp}")
        continue

    # Skip unrealistic temperatures
    if temp < -50 or temp > 50:
        print(f"Skipping unrealistic temp: {temp}")
        continue

    valid_temps.append(temp)

if valid_temps:
    avg_temp = sum(valid_temps) / len(valid_temps)
    print(f"\nValid temperatures: {valid_temps}")
    print(f"Average: {avg_temp:.2f}째C")
```

**Output:**
```
Skipping error reading: -999
Skipping unrealistic temp: 150
Skipping error reading: -999
Valid temperatures: [22.5, 23.1, 21.8, 24.2]
Average: 22.9째C
```

### Explanation
- Two-stage validation
- First continue: skip error sentinel (-999)
- Second continue: skip out-of-range values
- Valid range: -50 to 50째C
- 4 valid readings with average 22.9째C
- Real-world sensor data filtering

---

## Key Concepts Demonstrated

1. **Skip Iteration**: Continue jumps to next iteration immediately
2. **Filter Pattern**: Exclude unwanted items from processing
3. **Validation**: Skip invalid data without stopping loop
4. **Early Continue**: Place increment before continue in while loops
5. **Multiple Continues**: Can have several in one loop
6. **Nested Loops**: Continue only affects innermost loop
7. **Continue vs Break**: Continue skips, break exits
8. **Data Cleaning**: Remove errors, outliers, invalid entries
9. **Conditional Skip**: Complex conditions determine skip
10. **Input Validation**: Re-prompt without counting invalid

## Continue vs Break

| Feature | Continue | Break |
|---------|----------|-------|
| **Action** | Skip to next iteration | Exit loop entirely |
| **Loop continues?** | Yes | No |
| **Use case** | Filter items | Find and stop |
| **Example** | Skip negatives | Stop at sentinel |

## Best Practices

1. **Increment before continue**: In while loops, update counter before continue
2. **Provide feedback**: Print why item was skipped (debugging)
3. **Early continue**: Check skip conditions first, main logic last
4. **Avoid deep nesting**: Continue can flatten complex if-else
5. **Document intention**: Comment why continue is needed
6. **Combine with break**: Use both for flexible control
7. **Validate data**: Use continue for data cleaning
8. **Keep simple**: Don't overuse, maintain readability

## Common Patterns

```python
# Pattern 1: Filter unwanted items
for item in collection:
    if not_wanted(item):
        continue
    process(item)

# Pattern 2: Skip invalid data
while condition:
    data = get_data()
    if invalid(data):
        continue
    accumulate(data)

# Pattern 3: Multiple filters
for value in values:
    if condition1:
        continue
    if condition2:
        continue
    use(value)

# Pattern 4: Validation with retry
while attempts < max:
    input_data = get_input()
    if not valid(input_data):
        continue  # Don't count invalid
    attempts += 1
    process(input_data)
```
