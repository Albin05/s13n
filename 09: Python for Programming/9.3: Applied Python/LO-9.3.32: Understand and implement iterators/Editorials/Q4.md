## Problem 4: Fibonacci Iterator

```python
class FibonacciIterator:
    """Iterator for Fibonacci numbers up to max_value"""

    def __init__(self, max_value):
        self.max_value = max_value
        self.a = 0
        self.b = 1
        self.started = False

    def __iter__(self):
        """Return the iterator object"""
        return self

    def __next__(self):
        """Return the next Fibonacci number"""
        # Handle first number (0)
        if not self.started:
            self.started = True
            if self.a <= self.max_value:
                return self.a
            else:
                raise StopIteration

        # Check if current value exceeds max
        if self.b > self.max_value:
            raise StopIteration

        # Store current value
        current = self.b

        # Calculate next Fibonacci number
        self.a, self.b = self.b, self.a + self.b

        return current

# Test
fib = FibonacciIterator(50)
for num in fib:
    print(num, end=" ")
# Output: 0 1 1 2 3 5 8 13 21 34
```

### Explanation
1. `__init__()`: Initialize max_value, first two Fibonacci numbers (a=0, b=1), and a flag to track first iteration
2. `__iter__()`: Return self
3. `__next__()`:
   - First call: Return a (which is 0) if it doesn't exceed max
   - Subsequent calls: Check if b exceeds max, if yes raise StopIteration
   - Store current b value
   - Update a and b: a becomes b, b becomes a+b (next Fibonacci)
   - Return the stored value

**Sequence generation:**
- Initial: a=0, b=1
- Yield 0 (a), then a=1, b=1
- Yield 1 (b), then a=1, b=2
- Yield 1 (b), then a=2, b=3
- Yield 2 (b), then a=3, b=5
- And so on...

**Time Complexity:** O(1) per iteration
**Space Complexity:** O(1)
