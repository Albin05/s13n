## Problem 5: Prime Number Generator with Limit

```python
def prime_generator(limit):
    """Generator that yields prime numbers up to limit"""

    def is_prime(n):
        """Helper function to check if a number is prime"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False

        # Check odd divisors up to sqrt(n)
        for i in range(3, int(n ** 0.5) + 1, 2):
            if n % i == 0:
                return False
        return True

    # Start from 2 (first prime)
    for num in range(2, limit + 1):
        if is_prime(num):
            yield num

# Test
for prime in prime_generator(30):
    print(prime, end=" ")
# Output: 2 3 5 7 11 13 17 19 23 29
```

### Explanation

**Helper function `is_prime(n)`:**
1. Numbers less than 2 are not prime
2. 2 is prime (the only even prime)
3. All other even numbers are not prime
4. For odd numbers, check divisibility by odd numbers from 3 to √n
5. If any divisor is found, the number is not prime
6. If no divisors found, the number is prime

**Main generator:**
1. Iterate through all numbers from 2 to limit (inclusive)
2. For each number, check if it's prime using the helper function
3. If prime, yield it

**Why check only up to √n?**
If n has a divisor greater than √n, it must also have a divisor smaller than √n. So checking up to √n is sufficient.

**More efficient solution using Sieve of Eratosthenes:**
```python
def prime_generator(limit):
    """More efficient using Sieve of Eratosthenes"""
    if limit < 2:
        return

    # Create boolean array "prime[0..limit]"
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False

    p = 2
    while p * p <= limit:
        if is_prime[p]:
            # Mark multiples of p as not prime
            for i in range(p * p, limit + 1, p):
                is_prime[i] = False
        p += 1

    # Yield all numbers marked as prime
    for num in range(2, limit + 1):
        if is_prime[num]:
            yield num
```

**Time Complexity:**
- Simple approach: O(n * √n) where n is the limit
- Sieve approach: O(n log log n)

**Space Complexity:**
- Simple approach: O(1)
- Sieve approach: O(n) for the boolean array
