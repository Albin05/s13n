## Problem 5
```python
class Student:
    def __init__(self, name, student_id):
        self.name = name
        self.student_id = student_id
        self.enrolled_courses = []

    def __str__(self):
        return f"{self.name} ({self.student_id})"

class Professor:
    def __init__(self, name, employee_id, department):
        self.name = name
        self.employee_id = employee_id
        self.department = department

    def __str__(self):
        return f"Prof. {self.name}"

class Course:
    def __init__(self, course_code, name, professor):
        self.course_code = course_code
        self.name = name
        self.professor = professor
        self.enrolled_students = []

    def enroll_student(self, student):
        if student not in self.enrolled_students:
            self.enrolled_students.append(student)
            student.enrolled_courses.append(self)
            print(f"Enrolled {student.name} in {self.name}")
        else:
            print(f"{student.name} is already enrolled in {self.name}")

    def get_enrollment_count(self):
        return len(self.enrolled_students)

    def __str__(self):
        return f"{self.course_code}: {self.name} (Prof. {self.professor.name})"

class Department:
    def __init__(self, name):
        self.name = name
        self.courses = []

    def add_course(self, course):
        self.courses.append(course)
        print(f"Added {course.name} to {self.name} department")

    def get_total_enrollment(self):
        total = 0
        for course in self.courses:
            total += course.get_enrollment_count()
        return total

    def display_stats(self):
        print(f"\n=== {self.name} Department Statistics ===")
        print(f"Total Courses: {len(self.courses)}")
        print(f"Total Enrollment: {self.get_total_enrollment()}")
        print("\nCourse Details:")
        for course in self.courses:
            print(f"  {course}")
            print(f"    Instructor: {course.professor}")
            print(f"    Enrolled: {course.get_enrollment_count()} students")
            if course.enrolled_students:
                for student in course.enrolled_students:
                    print(f"      - {student}")

# Test the system
# Create professors
prof1 = Professor("Dr. Smith", "E001", "Computer Science")
prof2 = Professor("Dr. Johnson", "E002", "Computer Science")

# Create courses
course1 = Course("CS101", "Introduction to Programming", prof1)
course2 = Course("CS201", "Data Structures", prof2)

# Create department and add courses
cs_dept = Department("Computer Science")
cs_dept.add_course(course1)
cs_dept.add_course(course2)

# Create students
student1 = Student("Alice", "S001")
student2 = Student("Bob", "S002")
student3 = Student("Charlie", "S003")

# Enroll students
print("\n=== Enrollments ===")
course1.enroll_student(student1)
course1.enroll_student(student2)
course1.enroll_student(student3)
course2.enroll_student(student1)
course2.enroll_student(student2)

# Display statistics
cs_dept.display_stats()

# Show student's enrolled courses
print(f"\n=== {student1.name}'s Courses ===")
for course in student1.enrolled_courses:
    print(f"  - {course}")
```

### Explanation
- Complex composition with multiple object relationships
- `Course` HAS-A `Professor` (one-to-one composition)
- `Course` HAS-MANY `Students` (one-to-many composition/aggregation)
- `Department` HAS-MANY `Courses` (one-to-many composition)
- `Student` HAS-MANY `Courses` (many-to-many relationship through enrollment)
- `enroll_student()` maintains bidirectional relationship: adds course to student AND student to course
- This prevents inconsistent state where a student is in a course but course doesn't know about student
- The `display_stats()` method demonstrates navigating the composed object graph
- Objects maintain references to each other, creating a network of relationships
- This models real-world university structure where entities are interconnected

**Key Concepts**:
1. **Composition** represents HAS-A relationships (Car HAS-AN Engine)
2. **Aggregation** is weak composition where parts can exist independently (Library HAS Books)
3. **One-to-one**: one object contains one other object
4. **One-to-many**: one object contains multiple objects (collections)
5. **Many-to-many**: objects on both sides contain collections of each other
6. **Bidirectional relationships**: objects maintain references to each other
7. **Composition vs Inheritance**: use composition for HAS-A, inheritance for IS-A
8. **Modularity**: composed objects can be reused and tested independently
