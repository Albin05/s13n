## Problem 4
```python
class ShoppingCart:
    def __init__(self):
        self.items = []

    def add_item(self, name, price):
        self.items.append({"name": name, "price": price})
        print(f"Added {name} (${price}) to cart")

    def remove_item(self, name):
        for i, item in enumerate(self.items):
            if item["name"] == name:
                self.items.pop(i)
                print(f"Removed {name} from cart")
                return
        print(f"{name} not found in cart")

    def get_total(self):
        total = 0
        for item in self.items:
            total += item["price"]
        return total

    def display_cart(self):
        print("\n=== Shopping Cart ===")
        if len(self.items) == 0:
            print("Cart is empty")
        else:
            for item in self.items:
                print(f"- {item['name']}: ${item['price']}")
            print(f"\nTotal: ${self.get_total()}")

# Test the class
cart = ShoppingCart()
cart.add_item("Laptop", 999)
cart.add_item("Mouse", 25)
cart.add_item("Keyboard", 75)
cart.remove_item("Mouse")
cart.display_cart()
```

### Explanation
- Methods can work with complex data structures (lists of dictionaries)
- `add_item()` creates a dictionary and appends it to the list
- `remove_item()` iterates through the list to find and remove an item
- `get_total()` demonstrates accumulation pattern within a method
- `display_cart()` uses another method (`get_total()`) for calculation
- Methods provide a clean interface for complex operations
- The `return` statement in `remove_item()` exits early after finding the item
