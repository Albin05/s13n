## Problem 5: Cache Decorator with Expiry

```python
import time

def cache_with_expiry(expiry_seconds):
    """Decorator factory that caches results with expiry"""
    def decorator(func):
        cache = {}

        def wrapper(*args):
            current_time = time.time()

            # Check if result is in cache and not expired
            if args in cache:
                result, timestamp = cache[args]
                if current_time - timestamp < expiry_seconds:
                    return result

            # Calculate new result
            result = func(*args)
            cache[args] = (result, current_time)
            return result

        return wrapper
    return decorator

# Test
@cache_with_expiry(expiry_seconds=2)
def expensive_calculation(n):
    print(f"Calculating for {n}...")
    time.sleep(1)
    return n * n

print(expensive_calculation(5))
print(expensive_calculation(5))
time.sleep(3)
print(expensive_calculation(5))
```

### Explanation
Stores results with timestamps. Checks if cached result exists and hasn't expired before using it. If expired or not cached, recalculates and updates cache.
