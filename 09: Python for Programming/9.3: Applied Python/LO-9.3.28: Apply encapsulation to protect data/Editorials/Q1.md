## Problem 1
```python
class BankAccount:
    def __init__(self, initial_balance):
        self.__balance = initial_balance

    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited ${amount}. Balance: ${self.__balance}")
        else:
            print("Deposit amount must be positive")

    def withdraw(self, amount):
        if amount > self.__balance:
            print("Insufficient funds")
        elif amount > 0:
            self.__balance -= amount
            print(f"Withdrew ${amount}. Balance: ${self.__balance}")
        else:
            print("Withdrawal amount must be positive")

    def get_balance(self):
        return self.__balance

# Test the class
account = BankAccount(1000)
account.deposit(500)
account.withdraw(200)
print(f"Current balance: ${account.get_balance()}")

# Try to access private attribute directly
print("\nTrying to access __balance directly:")
try:
    print(account.__balance)
except AttributeError as e:
    print(f"Error: {e}")

# Python name mangling makes it accessible as _BankAccount__balance
print("\nPython's name mangling (not recommended to use):")
print(f"Accessing via name mangling: ${account._BankAccount__balance}")
```

### Explanation
- Double underscore `__` makes an attribute private (name mangling)
- Private attributes cannot be accessed directly from outside the class
- We provide public methods (`deposit`, `withdraw`, `get_balance`) as the interface
- This prevents direct manipulation of the balance, ensuring validation rules are enforced
- Python's name mangling changes `__balance` to `_ClassName__balance` internally
- While technically accessible via name mangling, this is considered bad practice
- Encapsulation protects data integrity by controlling how attributes are accessed and modified
