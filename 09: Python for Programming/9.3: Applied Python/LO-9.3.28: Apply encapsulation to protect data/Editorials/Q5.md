## Problem 5
```python
from datetime import datetime

class Account:
    def __init__(self, account_number, initial_balance):
        self.__account_number = account_number
        self.__balance = initial_balance
        self.__transaction_history = []
        self.__record_transaction("Opening", initial_balance)

    def __record_transaction(self, type, amount):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        transaction = {
            "timestamp": timestamp,
            "type": type,
            "amount": amount,
            "balance": self.__balance
        }
        self.__transaction_history.append(transaction)

    def deposit(self, amount):
        if amount <= 0:
            print("Deposit amount must be positive")
            return False
        self.__balance += amount
        self.__record_transaction("Deposit", amount)
        print(f"Deposited ${amount:.2f}. New balance: ${self.__balance:.2f}")
        return True

    def withdraw(self, amount):
        if amount <= 0:
            print("Withdrawal amount must be positive")
            return False
        if amount > self.__balance:
            print("Insufficient funds")
            return False
        self.__balance -= amount
        self.__record_transaction("Withdrawal", amount)
        print(f"Withdrew ${amount:.2f}. New balance: ${self.__balance:.2f}")
        return True

    def get_balance(self):
        return self.__balance

    def get_statement(self):
        print(f"\n{'='*60}")
        print(f"Account Statement - Account #{self.__account_number}")
        print(f"{'='*60}")
        print(f"{'Timestamp':<20} {'Type':<12} {'Amount':>10} {'Balance':>10}")
        print(f"{'-'*60}")
        for txn in self.__transaction_history:
            print(f"{txn['timestamp']:<20} {txn['type']:<12} "
                  f"${txn['amount']:>9.2f} ${txn['balance']:>9.2f}")
        print(f"{'-'*60}")
        print(f"Current Balance: ${self.__balance:.2f}")
        print(f"{'='*60}\n")

class SavingsAccount(Account):
    def __init__(self, account_number, initial_balance, interest_rate):
        super().__init__(account_number, initial_balance)
        self.__interest_rate = interest_rate

    def apply_interest(self):
        interest = self.get_balance() * (self.__interest_rate / 100)
        # Use parent's deposit to add interest
        print(f"Applying {self.__interest_rate}% interest: ${interest:.2f}")
        self.deposit(interest)

    def get_interest_rate(self):
        return self.__interest_rate

# Test the banking system
print("Creating checking account with $1000:")
checking = Account("CHK001", 1000)

print("\nPerforming transactions on checking account:")
checking.deposit(500)
checking.withdraw(200)
checking.withdraw(50)

checking.get_statement()

print("\nCreating savings account with $5000 at 3% interest:")
savings = SavingsAccount("SAV001", 5000, 3)

print("\nPerforming transactions on savings account:")
savings.deposit(1000)
savings.withdraw(500)
savings.apply_interest()

savings.get_statement()

print("Demonstrating encapsulation:")
print(f"Checking balance (through getter): ${checking.get_balance():.2f}")
print("\nTrying to access private attributes directly:")
try:
    print(checking.__balance)
except AttributeError:
    print("Cannot access __balance directly (encapsulated!)")

try:
    print(checking.__transaction_history)
except AttributeError:
    print("Cannot access __transaction_history directly (encapsulated!)")

print("\nAll data access must go through public methods!")
```

### Explanation
- All critical data is private: `__balance`, `__account_number`, `__transaction_history`
- Private method `__record_transaction()` is internal implementation detail
- Public methods provide controlled access to functionality
- Transaction history is maintained internally but only accessible through `get_statement()`
- The balance can be queried but not set directly
- `SavingsAccount` inherits but still cannot directly access parent's private attributes
- It must use public methods (`get_balance()`, `deposit()`) to interact with parent data
- This demonstrates strong encapsulation: implementation is hidden, only interface is exposed
- Private methods can change without affecting external code
- Data integrity is maintained through validation in public methods

**Key Concepts**:
1. **Encapsulation** hides internal state and requires interaction through methods
2. **Private attributes** use double underscore `__attribute` (name mangling)
3. **Public interface** provides controlled access to private data
4. **Validation** in setters ensures data integrity
5. **Properties** (`@property`) provide attribute-like access with method logic
6. **Read-only properties** have getters but no setters
7. **Information hiding** keeps implementation details private
8. **Security** through encapsulation prevents unauthorized access or modification
