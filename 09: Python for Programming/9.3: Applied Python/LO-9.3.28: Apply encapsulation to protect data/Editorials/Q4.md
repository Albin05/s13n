## Problem 4
```python
class Rectangle:
    def __init__(self, length, width):
        self.__length = None
        self.__width = None
        # Use setters for validation
        self.length = length
        self.width = width

    @property
    def length(self):
        return self.__length

    @length.setter
    def length(self, value):
        if value <= 0:
            raise ValueError("Length must be positive")
        self.__length = value

    @property
    def width(self):
        return self.__width

    @width.setter
    def width(self, value):
        if value <= 0:
            raise ValueError("Width must be positive")
        self.__width = value

    @property
    def area(self):
        return self.__length * self.__width

    @property
    def perimeter(self):
        return 2 * (self.__length + self.__width)

# Test the class
print("Creating rectangle with length=5, width=3:")
rect = Rectangle(5, 3)

print(f"Length: {rect.length}")
print(f"Width: {rect.width}")
print(f"Area: {rect.area}")
print(f"Perimeter: {rect.perimeter}")

print("\nChanging dimensions to length=10, width=4:")
rect.length = 10
rect.width = 4

print(f"New area: {rect.area}")
print(f"New perimeter: {rect.perimeter}")

print("\nTrying to set negative length:")
try:
    rect.length = -5
except ValueError as e:
    print(f"Error: {e}")

print("\nTrying to set area directly (read-only):")
try:
    rect.area = 100
except AttributeError as e:
    print(f"Error: can't set attribute (area is read-only)")

print(f"\nFinal dimensions: {rect.length} x {rect.width}")
print(f"Final area: {rect.area}")
```

### Explanation
- `@property` decorator creates a getter that looks like an attribute access
- `@attribute.setter` creates a setter with validation
- Properties allow attribute-like syntax (`rect.length`) while using method logic
- The actual attributes are private (`__length`, `__width`)
- Setters validate input, raising exceptions for invalid values
- Read-only properties (`area`, `perimeter`) have no setter
- This is computed property pattern: values calculated on demand
- Properties provide a clean interface while maintaining encapsulation
- You can change implementation without changing the interface
