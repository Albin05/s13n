## Problem 2
```python
class Temperature:
    def __init__(self, celsius):
        self.__celsius = None
        self.set_celsius(celsius)

    def get_celsius(self):
        return self.__celsius

    def set_celsius(self, value):
        if value < -273.15:
            print(f"Error: Temperature cannot be below absolute zero (-273.15°C)")
            print(f"Temperature remains at {self.__celsius}°C")
        else:
            self.__celsius = value
            print(f"Temperature set to {self.__celsius}°C")

    def get_fahrenheit(self):
        return (self.__celsius * 9/5) + 32

# Test the class
print("Creating temperature at 25°C:")
temp = Temperature(25)

print(f"\nCurrent temperature: {temp.get_celsius()}°C")
print(f"In Fahrenheit: {temp.get_fahrenheit():.1f}°F")

print("\nSetting to 100°C:")
temp.set_celsius(100)

print("\nTrying to set below absolute zero (-300°C):")
temp.set_celsius(-300)

print(f"\nFinal temperature: {temp.get_celsius()}°C")
```

### Explanation
- The `__celsius` attribute is private and can only be modified through `set_celsius()`
- The setter validates input, preventing invalid temperatures
- If validation fails, the temperature remains unchanged
- The getter provides read access to the value
- Encapsulation ensures data integrity by enforcing business rules in setters
- Additional methods like `get_fahrenheit()` can use the private data
- The constructor uses the setter to ensure validation even during initialization
