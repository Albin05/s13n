## Problem 3
```python
class Account:
    def __init__(self, account_number, balance):
        self.account_number = account_number
        self.balance = balance

    def withdraw(self, amount):
        if amount > self.balance:
            print("Insufficient funds")
        else:
            self.balance -= amount
            print(f"Withdrew ${amount}. New balance: ${self.balance}")

class SavingsAccount(Account):
    def withdraw(self, amount):
        # Check if withdrawal would go below minimum
        if self.balance - amount < 100:
            print("Cannot withdraw: Would go below minimum balance of $100")
            return

        # Charge fee if balance is below 500
        if self.balance < 500:
            print("Low balance fee: $5")
            self.balance -= 5

        # Perform withdrawal
        if amount > self.balance:
            print("Insufficient funds (including fees)")
        else:
            self.balance -= amount
            print(f"Withdrew ${amount}. New balance: ${self.balance}")

# Test the classes
print("Regular Account:")
account = Account("12345", 300)
account.withdraw(100)

print("\nSavings Account (balance: $300, withdraw $50):")
savings1 = SavingsAccount("67890", 300)
savings1.withdraw(50)

print("\nSavings Account (balance: $150, withdraw $60):")
savings2 = SavingsAccount("11111", 150)
savings2.withdraw(60)

print("\nSavings Account (balance: $600, withdraw $100):")
savings3 = SavingsAccount("22222", 600)
savings3.withdraw(100)
```

### Explanation
- The overridden method adds additional validation and business rules
- `SavingsAccount.withdraw()` checks minimum balance before allowing withdrawal
- It adds a fee system for low balances
- The child method is more complex than the parent's version
- This demonstrates how overriding allows specialization of behavior
- The method can have early returns to prevent further execution
- Same method interface, but with added constraints specific to savings accounts
