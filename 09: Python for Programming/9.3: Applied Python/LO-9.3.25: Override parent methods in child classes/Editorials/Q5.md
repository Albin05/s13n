## Problem 5
```python
from datetime import datetime

class Notification:
    def __init__(self, message):
        self.message = message
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def format_message(self):
        return f"[{self.timestamp}] {self.message}"

    def send(self):
        formatted = self.format_message()
        print(f"Sending notification: {formatted}")

class EmailNotification(Notification):
    def __init__(self, message, to, subject):
        self.message = message
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.to = to
        self.subject = subject

    def format_message(self):
        header = f"To: {self.to}\nSubject: {self.subject}\n"
        body = f"Timestamp: {self.timestamp}\n\n{self.message}"
        return header + body

    def send(self):
        formatted = self.format_message()
        print("=== Sending Email ===")
        print(formatted)
        print("Email sent successfully!\n")

class SMSNotification(Notification):
    def __init__(self, message, phone_number):
        self.message = message
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.phone_number = phone_number

    def format_message(self):
        # Truncate message to 160 characters
        max_length = 160
        if len(self.message) > max_length:
            truncated = self.message[:max_length-3] + "..."
        else:
            truncated = self.message
        return f"SMS to {self.phone_number}: {truncated}"

    def send(self):
        formatted = self.format_message()
        print("=== Sending SMS ===")
        print(formatted)
        print(f"Character count: {len(self.message)}/160")
        print("SMS sent successfully!\n")

class PushNotification(Notification):
    def __init__(self, message, app_name, priority):
        self.message = message
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.app_name = app_name
        self.priority = priority

    def format_message(self):
        badge = "ðŸ”´" if self.priority == "high" else "ðŸ”µ"
        return f"{badge} {self.app_name}\n{self.message}\n{self.timestamp}"

    def send(self):
        formatted = self.format_message()
        print("=== Sending Push Notification ===")
        print(formatted)
        print(f"Priority: {self.priority}")
        print("Push notification sent successfully!\n")

# Test the notification system
email = EmailNotification(
    "Your order has been shipped!",
    "customer@example.com",
    "Order Shipment Confirmation"
)

sms = SMSNotification(
    "Your verification code is 123456. This code will expire in 10 minutes. Please do not share this code with anyone for security purposes.",
    "+1234567890"
)

push = PushNotification(
    "New message from John",
    "ChatApp",
    "high"
)

# Send all notifications
email.send()
sms.send()
push.send()

# Demonstrate polymorphism
print("=== Sending All Notifications via Loop ===")
notifications = [email, sms, push]
for notification in notifications:
    notification.send()
```

### Explanation
- Both `send()` and `format_message()` are overridden in all child classes
- Each child provides notification-type-specific behavior
- `EmailNotification` adds email headers and recipient information
- `SMSNotification` enforces character limits and truncates messages
- `PushNotification` adds priority badges and app information
- All classes maintain the same interface (`send()` method)
- The datetime module is used to add timestamps
- String manipulation is used for formatting (truncation, concatenation)
- Despite different implementations, all notifications can be sent uniformly
- This demonstrates the power of polymorphism with method overriding

**Key Concepts**:
1. **Method overriding** replaces parent method implementation in child class
2. **Same signature**: overridden methods must have the same name and parameters
3. **Complete replacement**: child method completely replaces parent's version
4. **Polymorphism**: different classes can have methods with the same name but different behavior
5. **Specialization**: overriding allows child classes to customize inherited behavior
6. **Interface consistency**: maintaining the same method names enables uniform treatment of objects
