## Problem 4
```python
class Media:
    def __init__(self, title, duration):
        self.title = title
        self.duration = duration

    def play(self):
        print(f"Playing {self.title}")

class Song(Media):
    def __init__(self, title, duration, artist):
        self.title = title
        self.duration = duration
        self.artist = artist

    def play(self):
        print(f"Playing song: {self.title} by {self.artist}")
        print(f"Duration: {self.duration} minutes")

class Podcast(Media):
    def __init__(self, title, duration, episode_number):
        self.title = title
        self.duration = duration
        self.episode_number = episode_number

    def play(self):
        print(f"Playing podcast: {self.title} - Episode {self.episode_number}")
        print(f"Duration: {self.duration} minutes")

class Video(Media):
    def __init__(self, title, duration, resolution):
        self.title = title
        self.duration = duration
        self.resolution = resolution

    def play(self):
        print(f"Playing video: {self.title} in {self.resolution}")
        print(f"Duration: {self.duration} minutes")

# Test the classes
song = Song("Bohemian Rhapsody", 6, "Queen")
podcast = Podcast("Tech Talk", 45, 12)
video = Video("Python Tutorial", 30, "1080p")

song.play()
print()
podcast.play()
print()
video.play()

# Demonstrate polymorphism
print("\n=== Playing All Media ===")
media_list = [song, podcast, video]
for media in media_list:
    media.play()
    print()
```

### Explanation
- Each child class overrides `play()` with its own unique implementation
- All child classes add extra attributes specific to their media type
- The overridden methods use these additional attributes
- Despite different implementations, all have the same method name
- This enables polymorphism: we can treat all media objects uniformly
- The loop demonstrates calling `play()` on different types without knowing their specific class
- Each class customizes the behavior while maintaining a consistent interface
