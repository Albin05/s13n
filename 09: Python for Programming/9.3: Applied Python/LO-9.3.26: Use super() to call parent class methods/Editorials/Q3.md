## Problem 3
```python
class BankAccount:
    def __init__(self, account_number, balance):
        self.account_number = account_number
        self.balance = balance

    def deposit(self, amount):
        self.balance += amount
        print(f"Deposited ${amount}. Balance: ${self.balance}")

class InterestAccount(BankAccount):
    def __init__(self, account_number, balance, interest_rate):
        super().__init__(account_number, balance)
        self.interest_rate = interest_rate

    def deposit(self, amount):
        # Call parent deposit first
        super().deposit(amount)

        # Calculate and add interest
        interest = amount * (self.interest_rate / 100)
        self.balance += interest
        print(f"Interest earned: ${interest:.2f}. New balance: ${self.balance:.2f}")

# Test the class
account = InterestAccount("12345", 1000, 5)
print("Initial balance:", account.balance)
print()

account.deposit(500)
print()
account.deposit(200)
```

### Explanation
- The child's `deposit()` first calls `super().deposit(amount)` to execute parent logic
- This ensures the parent's deposit functionality is preserved
- After parent's deposit completes, child adds interest calculation
- Using `super()` avoids duplicating the deposit logic
- The balance is updated twice: once by parent, once for interest
- This demonstrates extending method behavior while reusing parent code
