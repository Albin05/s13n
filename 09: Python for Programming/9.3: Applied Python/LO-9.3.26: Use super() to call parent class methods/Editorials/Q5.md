## Problem 5
```python
from datetime import datetime

class Logger:
    def log(self, message):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] Logger: {message}")

class FileLogger(Logger):
    def log(self, message):
        print("  → FileLogger: Calling parent...")
        super().log(message)
        print("  → FileLogger: Writing to file: log.txt")

class EmailLogger(FileLogger):
    def log(self, message):
        print("  → EmailLogger: Calling parent...")
        super().log(message)
        print("  → EmailLogger: Sending email to admin@example.com")

class AlertLogger(EmailLogger):
    def log(self, message):
        print("  → AlertLogger: Calling parent...")
        super().log(message)
        print("  → AlertLogger: Triggering alert notification")

# Test the logging system
print("=== Creating AlertLogger ===")
logger = AlertLogger()

print("\n=== Logging a critical message ===")
print("Execution flow:")
logger.log("CRITICAL: System failure detected!")

print("\n" + "="*50)
print("Order of execution:")
print("1. AlertLogger.log() starts")
print("2. Calls super() -> EmailLogger.log()")
print("3. EmailLogger calls super() -> FileLogger.log()")
print("4. FileLogger calls super() -> Logger.log()")
print("5. Logger.log() executes (base implementation)")
print("6. Returns to FileLogger, writes to file")
print("7. Returns to EmailLogger, sends email")
print("8. Returns to AlertLogger, triggers alert")
```

### Explanation
- This demonstrates cascading `super()` calls through multiple inheritance levels
- Each class calls `super().log()` before adding its own functionality
- The call chain: AlertLogger → EmailLogger → FileLogger → Logger
- Logger (base class) executes first, then control returns up the chain
- Each level adds its functionality as control returns from `super()`
- This creates a "wrapper" pattern where each level wraps the parent's behavior
- The execution order is: down to base (via super), then up (adding functionality)
- All four log implementations execute from a single `logger.log()` call
- This demonstrates the power of `super()` in creating extensible, layered functionality

**Key Concepts**:
1. **super()** provides access to parent class methods without naming the parent
2. **Code reuse**: calling parent methods avoids duplicating code
3. **Extension vs replacement**: `super()` extends behavior instead of replacing it
4. **Initialization chaining**: `super().__init__()` properly initializes parent attributes
5. **Method chaining**: multiple inheritance levels can chain calls using `super()`
6. **Execution flow**: `super()` calls go down to base, execution happens on the way back up
7. **Maintainability**: changing parent class name doesn't break child classes using `super()`
