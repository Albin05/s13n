### Q5: Event Attendance Tracker

**Solution:**

```python
# Read number of sessions
n = int(input())

# Track all unique attendees and attendance count per person
all_attendees = set()
attendance_count = {}
session_names = []

# Process each session
for _ in range(n):
    line = input()

    # Parse session: "Session1: Alice Bob Charlie"
    parts = line.split(': ')
    session_name = parts[0]
    attendees = parts[1].split()

    session_names.append(session_name)

    # Add to overall set
    all_attendees.update(attendees)

    # Count attendance for each person
    for person in attendees:
        attendance_count[person] = attendance_count.get(person, 0) + 1

# Find attendees in multiple sessions
multiple_sessions = sorted([
    person for person, count in attendance_count.items() if count > 1
])

# Find most frequent attendee
max_attendance = max(attendance_count.values())
most_frequent = sorted([
    person for person, count in attendance_count.items()
    if count == max_attendance
])[0]

# Calculate average
total_session_attendees = sum(len(s.split(': ')[1].split())
                               for s in session_names)
avg_per_session = sum(len(set(s.split(': ')[1].split()))
                       for s in session_names) / n

# Output results
print(f"Total unique attendees: {len(all_attendees)}")
print(f"Attendees in multiple sessions: {' '.join(multiple_sessions)}")
print(f"Most frequent attendee: {most_frequent} ({max_attendance} sessions)")
print(f"Sessions held: {n}")
print(f"Average unique per session: {avg_per_session:.1f}")
```

**Alternative Cleaner Solution:**

```python
n = int(input())

all_attendees = set()
attendance_count = {}
session_data = []

# Collect data
for _ in range(n):
    line = input()
    session_name, attendees_str = line.split(': ')
    attendees = set(attendees_str.split())

    session_data.append(attendees)
    all_attendees.update(attendees)

    for person in attendees:
        attendance_count[person] = attendance_count.get(person, 0) + 1

# Analysis
multiple_sessions = sorted([p for p, c in attendance_count.items() if c > 1])
max_count = max(attendance_count.values())
most_frequent = sorted([p for p, c in attendance_count.items() if c == max_count])[0]
avg_unique = sum(len(s) for s in session_data) / n

# Output
print(f"Total unique attendees: {len(all_attendees)}")
print(f"Attendees in multiple sessions: {' '.join(multiple_sessions)}")
print(f"Most frequent attendee: {most_frequent} ({max_count} sessions)")
print(f"Sessions held: {n}")
print(f"Average unique per session: {avg_unique:.1f}")
```

**Explanation:**

1. **Data structures:**
   - `all_attendees`: set for unique attendees across all sessions
   - `attendance_count`: dict to track how many sessions each person attended
   - `session_data`: list of sets, one per session

2. **update() usage:** `all_attendees.update(attendees)` adds all attendees from current session

3. **Frequency counting:** Dictionary tracks attendance count per person

4. **Multiple sessions:** List comprehension filters people with count > 1

5. **Most frequent:**
   - Find max count
   - Filter people with max count
   - Sort alphabetically and take first (tie-breaking)

6. **Statistics:** Calculate average unique attendees per session

**Key Concepts:**
- Combining sets with update() for union operation
- Using dictionary for counting/aggregation
- List comprehensions for filtering
- Set provides O(1) membership testing

**Time Complexity:** O(n*m) where n is sessions and m is average attendees
**Space Complexity:** O(a) where a is total unique attendees

---

## Common Patterns Used

1. **Deduplication:** Using set's automatic uniqueness
2. **Bulk Addition:** update() for adding multiple elements
3. **Tracking Changes:** Comparing len() before and after
4. **Case Normalization:** Converting to lowercase for case-insensitive comparison
5. **Generator Expressions:** Memory-efficient transformation during update()
6. **Membership Testing:** Fast O(1) lookups with `in` operator

## Performance Tips

1. Use update() instead of looping with add() for multiple elements
2. Generator expressions with update() are memory-efficient
3. Set membership testing is O(1) average case
4. Combining sets is faster than manual iteration
