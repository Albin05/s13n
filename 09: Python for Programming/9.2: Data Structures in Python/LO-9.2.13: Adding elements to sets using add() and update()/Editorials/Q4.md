### Q4: Permission Manager

**Solution:**

```python
# Define role permissions
ROLES = {
    'VIEWER': ['read'],
    'EDITOR': ['read', 'write', 'edit'],
    'ADMIN': ['read', 'write', 'edit', 'delete', 'manage_users']
}

# Initialize permissions set
permissions = set()

# Process commands
while True:
    command = input().split()

    if command[0] == 'done':
        break

    elif command[0] == 'grant':
        permission = command[1]
        permissions.add(permission)
        print(f"Granted: {permission}")

    elif command[0] == 'grant_role':
        role_name = command[1]
        role_perms = ROLES[role_name]

        # Track new permissions
        before = len(permissions)
        permissions.update(role_perms)
        after = len(permissions)
        new_count = after - before

        print(f"Granted role {role_name}: {new_count} new permissions")

    elif command[0] == 'check':
        permission = command[1]
        has_perm = permission in permissions
        print(f"Has permission '{permission}': {has_perm}")

    elif command[0] == 'show':
        print(f"Permissions: {' '.join(sorted(permissions))}")
```

**Explanation:**

1. **Role definition:** Dictionary maps role names to permission lists
2. **add() for individual:** Single permission granted with add()
3. **update() for roles:** All role permissions added at once with update()
4. **Membership testing:** `permission in permissions` is O(1) average case
5. **Count new permissions:** Some role permissions may already exist
6. **Display sorted:** Shows permissions in alphabetical order

**Design Choice:**
- Using set for permissions enables fast lookup (O(1) vs O(n) for list)
- update() prevents duplicate permissions automatically
- Role-based access control (RBAC) is common security pattern

**Time Complexity:** O(1) for grant/check, O(r) for grant_role where r is role size
**Space Complexity:** O(p) where p is unique permissions
