### Q5: Task Queue Processor

**Solution:**

```python
# Parse initial pending tasks
line = input()
pending = set(line.split(': ')[1].split())
processing = set()
completed = set()

# Process commands
while True:
    command = input().split()

    if command[0] == 'stats':
        print("--- Queue Statistics ---")
        print(f"Pending: {len(pending)} tasks ({' '.join(sorted(pending))})")
        print(f"Processing: {len(processing)} tasks ({' '.join(sorted(processing))})")
        print(f"Completed: {len(completed)} tasks ({' '.join(sorted(completed))})")
        break

    action = command[0]
    task_id = command[1]

    if action == 'start':
        # Must be in pending to start
        if task_id in pending:
            pending.remove(task_id)
            processing.add(task_id)
            print(f"Started {task_id} (pending → processing)")
        else:
            print(f"Cannot start {task_id}: not in pending queue")

    elif action == 'complete':
        # Must be in processing to complete
        if task_id in processing:
            processing.remove(task_id)
            completed.add(task_id)
            print(f"Completed {task_id} (processing → completed)")
        else:
            print(f"Cannot complete {task_id}: not in processing")

    elif action == 'fail':
        # Must be in processing to fail (move back to pending)
        if task_id in processing:
            processing.remove(task_id)
            pending.add(task_id)
            print(f"Failed {task_id} (processing → pending)")
        else:
            print(f"Cannot fail {task_id}: not in processing")
```

**Explanation:**

1. **Three sets**: pending, processing, completed for task lifecycle
2. **start**: Check membership first, use remove() for validation, add to processing
3. **complete**: Check membership, use remove(), add to completed
4. **fail**: Check membership, use remove(), add back to pending
5. **Validation**: Check membership before remove() to provide meaningful error messages

**Why remove() here instead of discard()?**
- We want to enforce state rules
- If task isn't in expected state, that's an error condition
- Better to validate explicitly with membership check

**Alternative using try-except:**

```python
elif action == 'start':
    try:
        pending.remove(task_id)
        processing.add(task_id)
        print(f"Started {task_id} (pending → processing)")
    except KeyError:
        print(f"Cannot start {task_id}: not in pending queue")
```

**Key Learning:**
- Use remove() when state transitions have strict rules
- Check membership first for better error messages
- OR use try-except to catch KeyError

---

## Common Patterns Summary

1. **Safe User Actions**: Use discard()
   ```python
   cart.discard(item_id)  # User removes item
   ```

2. **State Validation**: Use remove() with try-except or membership check
   ```python
   if task_id in pending:
       pending.remove(task_id)
   ```

3. **Tracking Changes**: Compare len() before and after
   ```python
   before = len(my_set)
   my_set.discard(item)
   after = len(my_set)
   changed = (before != after)
   ```

4. **Bulk Removal**: Use discard() in loop
   ```python
   for item in items_to_remove:
       my_set.discard(item)
   ```

5. **Critical Item Protection**: Check before removing
   ```python
   if item not in PROTECTED:
       my_set.discard(item)
   ```

## Performance Notes

- Both remove() and discard() are O(1) average case
- Membership check `item in set` is also O(1) average case
- Combined check + remove is still O(1)
