### Q5 Solution: Caching with Tuples

```python
# Cache and stats
cache = {}
stats = {'hits': 0, 'misses': 0}

def expensive_calculation(a, b, c):
    """Simulates expensive computation"""
    return (a ** 2) + (b ** 3) + (c ** 4)

def cached_calculation(a, b, c):
    key = (a, b, c)  # Tuple as cache key
    
    if key in cache:
        stats['hits'] += 1
        print(f"  Cache HIT! Returning cached value")
        return cache[key]
    else:
        stats['misses'] += 1
        print(f"  Cache MISS - computing...")
        result = expensive_calculation(a, b, c)
        cache[key] = result
        return result

def cache_stats_display():
    total = stats['hits'] + stats['misses']
    hit_rate = (stats['hits'] / total * 100) if total > 0 else 0
    print(f"\nCache Statistics:")
    print(f"  Total calls: {total}")
    print(f"  Cache hits: {stats['hits']}")
    print(f"  Cache misses: {stats['misses']}")
    print(f"  Hit rate: {hit_rate:.1f}%")

print("Cache initialized\n")

# Test calls
test_cases = [
    (2, 3, 4),
    (1, 2, 3),
    (2, 3, 4),  # Should hit
    (1, 2, 3),  # Should hit
    (5, 6, 7)
]

for args in test_cases:
    print(f"Call cached_calculation{args}:")
    result = cached_calculation(*args)
    print(f"  Result: {result}")
    print(f"  Cache now has {len(cache)} {'entry' if len(cache) == 1 else 'entries'}\n")

cache_stats_display()

# Try list as key
print("\nAttempting to use list [2, 3, 4] as cache key:")
try:
    test_cache = {}
    test_cache[[2, 3, 4]] = 'value'
except TypeError as e:
    print(f"TypeError: {e}\n")
    print("Explanation: Lists cannot be dictionary keys because:")
    print("  1. Lists are mutable (can change)")
    print("  2. Mutable objects cannot be hashed")
    print("  3. Dictionary keys must be hashable")
    print("  4. Tuples are immutable and hashable - perfect for caching!")
```

**Caching Pattern:**
- Use tuple of arguments as key
- Immutable = safe cache key
- Hashable = can be dict key
- Common in memoization, dynamic programming

**Key Takeaways:**
- Immutability enables safe caching
- Tuples perfect for composite keys
- Lists fail as keys (unhashable)
- Pattern used in real optimization
