### Q5 Solution: CSV Data Processor

```python
# 1. CSV data
csv_data = [
    "101,Alice,Engineering,95000,5",
    "102,Bob,Marketing,75000,3",
    "103,Charlie,Engineering,105000,7",
    "104,Diana,HR,65000,2",
    "105,Eve,Engineering,98000,4"
]

# 2. Parse employee function
def parse_employee(csv_string):
    # Split and unpack
    emp_id, name, department, salary, years = csv_string.split(',')
    
    # Convert types and pack
    return int(emp_id), name, department, int(salary), int(years)

# 3. Calculate bonus function
def calculate_bonus(employee):
    # Unpack employee data
    emp_id, name, department, salary, years = employee
    
    # Calculate bonus
    base_rate = 0.05  # 5%
    years_rate = 0.01 * years  # 1% per year
    
    # Engineers get extra 2%
    engineering_bonus = 0.02 if department == 'Engineering' else 0
    
    total_rate = base_rate + years_rate + engineering_bonus
    bonus = salary * total_rate
    
    # Pack and return
    return name, bonus

# 4. Process all employees
employees = []
department_bonuses = {}

for csv_string in csv_data:
    # Parse employee
    employee = parse_employee(csv_string)
    employees.append(employee)
    
    # Unpack for processing
    emp_id, name, department, salary, years = employee
    
    # Calculate bonus
    bonus_name, bonus = calculate_bonus(employee)
    
    # Print employee bonus
    print(f"{name} ({department}, {years} years): Bonus = ${bonus:.2f}")
    
    # Track by department
    if department not in department_bonuses:
        department_bonuses[department] = 0
    department_bonuses[department] += bonus

# Calculate total bonus
total_bonus = sum(department_bonuses.values())
print(f"\nTotal bonus budget: ${total_bonus:.2f}")

# Find department with highest bonuses
max_dept = max(department_bonuses.items(), key=lambda item: item[1])
dept_name, dept_bonus = max_dept  # Unpack the result
print(f"Department with highest bonuses: {dept_name} (${dept_bonus:.2f})")
```

**Explanation:**

**Parsing with Unpacking:**
```python
emp_id, name, department, salary, years = csv_string.split(',')
```
- `split(',')` returns a list of 5 strings
- Unpack directly into variables
- Then convert types as needed

**Type Conversion Pattern:**
```python
return int(emp_id), name, department, int(salary), int(years)
```
- Convert and pack in one step
- Returns properly typed tuple

**Multiple Unpacking Stages:**
```python
# Stage 1: Parse CSV
employee = parse_employee(csv_string)

# Stage 2: Unpack for processing
emp_id, name, department, salary, years = employee

# Stage 3: Calculate bonus
bonus_name, bonus = calculate_bonus(employee)
```

**Dictionary Items Unpacking:**
```python
max_dept = max(department_bonuses.items(), key=lambda item: item[1])
dept_name, dept_bonus = max_dept
```
- `items()` returns (key, value) tuples
- `max()` returns one tuple
- Unpack to get department name and bonus

**Bonus Challenge Solution:**
```python
def parse_employee_flexible(csv_string):
    """Handle variable number of fields"""
    parts = csv_string.split(',')
    
    # Use extended unpacking
    emp_id, name, *optional_fields = parts
    
    # Provide defaults
    department = optional_fields[0] if len(optional_fields) > 0 else 'Unknown'
    salary = int(optional_fields[1]) if len(optional_fields) > 1 else 0
    years = int(optional_fields[2]) if len(optional_fields) > 2 else 0
    
    return int(emp_id), name, department, salary, years

# Test with variable-length data
test_data = [
    "101,Alice,Engineering,95000,5",
    "102,Bob,Marketing,75000",
    "103,Charlie"
]

for csv in test_data:
    emp = parse_employee_flexible(csv)
    print(emp)
```

**Key Patterns:**
1. **String parsing** â†’ unpack immediately
2. **Type conversion** during packing
3. **Function chaining** with pack/unpack
4. **Aggregation** using unpacked data
5. **Dictionary iteration** with key-value unpacking

---

### Key Takeaways

**Unpacking Patterns:**

1. **Basic:** `a, b, c = tuple`
2. **Extended:** `first, *rest = tuple`
3. **Selective:** `first, *_, last = tuple`
4. **Nested:** `a, (b, c) = (1, (2, 3))`

**Common Use Cases:**

1. **Function Returns:**
```python
def get_stats():
    return min_val, max_val, avg
    
minimum, maximum, average = get_stats()
```

2. **Loop Iteration:**
```python
for name, score in student_scores:
    print(f"{name}: {score}")
```

3. **Swapping:**
```python
a, b = b, a
```

4. **Parsing:**
```python
name, age, city = csv_row.split(',')
```

**Best Practices:**

1. Use extended unpacking for flexible data
2. Use `_` for ignored values
3. Unpack at function boundaries for clarity
4. Pack multiple return values instead of dictionaries (when appropriate)
5. Leverage unpacking in loops for cleaner code
