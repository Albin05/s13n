### Q3 Solution: Data Transformation System

```python
# 1. Create points list
points = [(0, 0), (3, 4), (6, 8), (1, 2)]

# 2. Translation function
def translate_point(point, dx, dy):
    x, y = point  # Unpack coordinates
    return x + dx, y + dy  # Pack and return

# 3. Scale function
def scale_point(point, factor):
    x, y = point  # Unpack
    return x * factor, y * factor  # Pack and return

# 4. Reflect function
def reflect_point(point):
    x, y = point  # Unpack
    return -x, y  # Pack and return (negate x)

# 5. Process each point
for original in points:
    # Chain transformations
    translated = translate_point(original, 5, 5)
    scaled = scale_point(translated, 2)
    final = reflect_point(scaled)
    
    # Unpack for printing
    ox, oy = original
    tx, ty = translated
    sx, sy = scaled
    fx, fy = final
    
    print(f"Original: ({ox}, {oy}) → Translated: ({tx}, {ty}) → Scaled: ({sx}, {sy}) → Reflected: ({fx}, {fy})")
```

**Explanation:**

**Function Pattern:**
```python
def translate_point(point, dx, dy):
    x, y = point      # Unpack input
    return x + dx, y + dy  # Pack output
```

**Key Points:**
1. **Unpack at start:** Extract coordinates from tuple
2. **Process:** Perform calculations
3. **Pack at return:** Return new tuple automatically

**Transformation Chain:**
```python
(0, 0) → translate(5,5) → (5, 5)
(5, 5) → scale(2) → (10, 10)
(10, 10) → reflect → (-10, 10)
```

**Loop Unpacking:**
```python
for original in points:  # Each 'original' is a tuple
    # Can also unpack directly:
    # for x, y in points:
```
